### 好的实践

依赖反转（DI）不是火箭科学。我们只需要避免新建和单例，除了有使用他们的原因，比如一个没有外部依赖工具方法，或者一个工具类在框架之外没有任何目的（互操作性包裹器和字典键是这个的常见例子）。

IoC 框架的很多问题在于当开发者第一次学习怎样使用他们，不是真正的改变他们处理依赖和抽象去满足 IoC 模型 的方式，而是尝试操作 IoC 容器去迎合他们旧的代码风格的期待，往往带来高耦合和低内聚。

### 使用一个组合根去避免服务定位器反模式

我们的应用依赖树应该有一个唯一的根元素（也叫做应用组合根），也是我们应该调用 resolve 方法唯一的组件。

每一次我们需要注入一些东西，就调用 resolve，就像服务定位器是一个反模式。如果我们使用一个 MVC 框架，组合根应该在应用类，独立于路由逻辑或者控制器工具类。

### 避免构造器过分注入

构造器过分注入违背单一职责原则。太多构造器参数预示着太多的依赖；太多依赖预示着类尝试做很多的事情。通常这个错误和其他代码味道混合，比如不常见的长度和模糊（“manager”）类名。

### 避免数据注入，而不是行为

数据注入，而不是行为，是幽灵反模式的子类型，这个场景中，geist 是容器。如果一个类需要意识到当前的日期和实践，比不需要注入一个 DateTime，这是数据；而是注入一个系统时钟。这不仅对 DI 是正确的；这对于可测试性是必要的，你可以测试随实践变化的函数，而不是需要真正的等待他们。

### 避免声明每一个声明周期为单例

对我来说，声明每一个生命周期为单例是一个货物崇拜编程最好的例子，在某种程度上，也叫做“对象粪坑”。我见过更多单例滥用比我记得的多，很少是关于 DI。

### 避免特定于实现的接口类型

其他常见错误是实现指定接口类型，就是为了能够注册到容器。这本身就违背了依赖倒置原则（只是因为他是一个接口，不意味着他真正的抽象），通常还包含接口膨胀和违背接口隔离原则。

### 避免可选的依赖

换句话说，存在构造器接受依赖注入，也存在其他构造器使用一个“默认”实现。这也违背 DIP 并导致 LSP 的违背，作为开发者，随着实践，开始对默认实现进行假设，和/或开始泗洪默认构造函数实例。